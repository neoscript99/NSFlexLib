<?xml version="1.0" encoding="utf-8"?>
<mx:TextInput xmlns:mx="http://www.adobe.com/2006/mxml" valueCommit="changeHandle()"
			  keyDown="onKeyDown(event)" creationComplete="cc()" maxChars="32">
	<mx:Metadata>
		[Event(name="enterKeyDown")]
	</mx:Metadata>
	<mx:Script>
		<![CDATA[
			import ns.flex.util.StringUtil;
			import mx.events.ValidationResultEvent;
			import mx.validators.Validator;
			import mx.validators.RegExpValidator;
			[Inspectable(category="General")]
			public var noSpace:Boolean=false;
			[Inspectable(category="General")]
			public var autoTrim:Boolean=true;
			[Inspectable(enumeration="true,false", defaultValue="true",
				category="General")]
			public var imeDisabled:Boolean=false;
			public var ignorePattern:RegExp;
			private var validator:RegExpValidator;
			public var noMatchError:String="格式错误";
			public var requiredFieldError:String="不能为空";
			public var flags:String;
			public var expression:String;
			[Inspectable(category="General")]
			public var required:Boolean=false;
			
			public function set constraints(value:Object):void
			{
				for (var prop:String in value)
					if (hasOwnProperty(prop))
						this[prop]=value[prop];
			}
			
			public function resetValidator():void
			{
				if (validator)
					validator.enabled=false;
				
				if (expression || required)
				{
					validator=new RegExpValidator();
					validator.expression=expression ? expression : '.';
					validator.flags=flags;
					validator.required=required;
					validator.noMatchError=
						noMatchError.concat('(', expression, flags ? ' ' + flags : '',
						')');
					validator.requiredFieldError=requiredFieldError;
					validator.source=this;
					validator.property='text';
					validator.trigger=this;
					validator.triggerEvent="valueCommit";
				}
			}
			
			[Bindable("textChanged")]
			[Bindable("maxCharsChanged")]
			public function get remainSize():int
			{
				return maxChars - text.length;
			}
			
			[Bindable("valueCommit")]
			public function get validated():Boolean
			{
				return validator ? (validator.validate().type == ValidationResultEvent.VALID) : true;
			}
			
			private function cc():void
			{
				resetValidator();
			}
			
			private function onKeyDown(evt:KeyboardEvent):void
			{
				if (evt.keyCode == Keyboard.ENTER)
					this.dispatchEvent(new Event('enterKeyDown'));
			}
			
			override protected function focusInHandler(event:FocusEvent):void
			{
				super.focusInHandler(event);
				IME.enabled=!imeDisabled;
			}
			
			override protected function focusOutHandler(event:FocusEvent):void
			{
				super.focusOutHandler(event);
				IME.enabled=true;
			}
			
			private function changeHandle():void
			{
				if (noSpace)
					text=StringUtil.removeSpace(text);
				else if (autoTrim)
					text=StringUtil.trim(text);
				
				if (ignorePattern)
					text=text.replace(ignorePattern, '');
			}
		]]>
	</mx:Script>
</mx:TextInput>
